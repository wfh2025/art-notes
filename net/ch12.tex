\documentclass{../main.tex}{subfiles}
\begin{document}
\chapter{TCP:传输控制协议(初步)}
\section{引言}
% CRC和校验，只能检测有差错数据，但是无法纠正
% IP和UDP，没有实现纠正
% 以太网及其上的协议，提供一定次数尝试，失败则放弃
到目前为止，我们一直在讨论那些自身不包含可靠传递数据机制的协议。
它们可能回使用一种像校验或CRC这样的数学函数来检测接收到的有差错的数据，但是它们不尝试去纠正差错。
对于IP和UDP，根本没有实现差错纠正。
对于以太网和基于其上的其他协议，协议提供一定次数的尝试，如果还是不成功则放弃。

% 尽量避免信息在通信信道出错方法:
% 1. 差错纠正码
% 2. 重试，ARQ
通信媒介可能会丢失或改变被传递的信息，在这种环境下的通信问题已经被研究了多年。
关于这个课题的一些最重要的理论工作由克劳德\textperiodcentered 香农在1948年给出\cite{Shannon1948A}。
这些工作普及了术语``比特''，并成为\emph{信息理论}(information theory)领域的基础，
    帮助我们理解了在一个有损(可能会删除或改变比特)信道里可通过的信息量的根本限制，
信息理论与\emph{编码理论}(coding theory)的领域密切相关，编码理论提供不同的信息编码手段，从而使得信息能在通信信道里尽量免于出错。
使用\emph{差错校正码}(基本上是添加一些冗余的比特，使得即使某些比特被毁，真实的信息也可以被恢复过来)来纠正通信问题是处理差错的一种非常重要的方法。
另一种方法是简单地``尝试重新发送''，直到信息最终被接收。
这种方法，称为\emph{自由重复请求}(Automatic Repeat Request, ARQ)，构成了许多通信协议的基础，包括TCP在内。


\subsection{ARQ和重传}
如果我们考虑的不只是单个通信信道，而是几个的多跳级联，我们会发现不只会碰到前面提到的那几种差错类型(分组比特差错)，而且还会有更多其他的类型。
这些问题可能发生在中间路由器上，是几种在讨论IP时会遇到的问题:分组重新排序，分组复制，分组泯灭(丢失)。
在多跳通信信道(例如IP)上使用而设计的带纠错的协议必须要处理这些问题。
现在让我们探讨能处理这些问题的协议机制。在概括性地讨论这些之后，我们会探究它们是如何被TCP在互联网上使用的。

% 重发直到它被接收，关键点:
% 1. 怎样判定接收方已收到 ==> ACK
% 2. 和之前收到的是否相同 ==> 序列号
% 
% 引入ACK带来的问题：
% 1. 发送方对ACK应该等待多久
% 2. ACK丢失 ==> 重试(无法判定是ACK丢失还是分组丢失)
% 3. 接收到的分组数据有错 ==> 编码技术纠正或检测错误 ==> 收到错误的分组，不发送ACK
一个直接处理分组丢失(和比特差错)的方法是重发分组直到它被正确接收。这需要一种方法来判断: 
(1) 接收方是否已收到分组; (2) 接收方接收到的分组是否与之前发送方发送的一样。
接收方给发送方发信号以确定自己已经接收到一个分组，这种方法称为\emph{确认}(acknowledgment)，或ACK。
最基本的形式是，发送方发送一个分组，然后等待一个ACK。当接收方接收到这个分组时，它发送对应的ACK。
当发送方接收到这个ACK，它再发送另一个分组，这个过程就这样继续。这里会有一些有意思的问题:
(1) 发送方对一个ACK应该对待多长时间？ (2) 如果ACK丢失了怎么办？ (3) 如果分组被接收到了，但是里面有错怎么办？

正如我们将看到的，第一个问题是挺深奥的。
决定去等待时间多长时间与发送方\emph{期待}(expect)为一个ACK等待多长时间有关。 % 没看懂，这是啥意思?
现在确定这个时间可能比较困难，因此我们推迟对这个技术的讨论，直到我们在后面(见第14章)详细讨论TCP。
第二个问题的答案比较容易: 如果第一个ACK丢失了，发送方不能轻易地把这种情况与原分组的情况区分开来，所以它简单地再次发送分组。
当然，这样的话，接收方可能会收到两个或更多的拷贝，因此必须准备好处理这种情况(见下一段)。
至于第三个问题，我们可以借助12.1节中提到的编码技术来解决。
使用编码技术来检测一个大的分组中的差错(有很大的概率)一般都很简单，仅使用比其自身小很多的一些比特即可纠正。
更简单的编码一般不能纠正差错，但是能检测它们。
这就是校验和CRC会如此受欢迎的原因。
然后，为了检测分组里的差错，我们使用一种校验和形式。
当一个接收方接收到一个含有差错的分组时，它不发送ACK。
最后，发送方重发完整到达的无差错的分组。

% 用序列号来去重
到目前为止即使这种简单的场景，接收方都可能接收到被传送分组的\emph{重复}(duplicate)副本。
这个问题要使用\emph{序列号}(sequence number)来处理。
基本上，在被源端发送时，每个唯一的分组都有一个新的序列号，这个序列号由分组自身一直携带着。
接收方可以使用这个序列号来判断它是否已经见过这个分组，如果见过则丢弃它。

% 停止和等待协议的吞吐性能低
到目前为止介绍的协议是可靠的，但是效率不太高。
如果从发送方到接收方传递即使一个很小的分组都要用很长时间(推迟或延迟)的话(如一秒或两秒，对卫星链路来说并非不正常)，考虑一下那会怎样。
发送方可以注入一个分组到通信路径，然后停下来直到知道它收到ACK。
这个协议因此被称为``停止和等待''。
假设没有分组在传输中丢失和无可挽回地损害，该吞吐量性能(每单位时间发送在网络中的数据量)与$M/R$成正比，$M$是分组大小，$R$是往返时间(RTT)。
如果有分组丢失和损害的话，情况甚至更糟糕: “吞吐质”(每单位时间传送的有用数据量)明显比吞吐量要低。

% 等待导致性能差，允许多个分组进入网络以便于提升性能，多个分组会引入其他问题
对于不会损害和丢失太多分组的网络来说，低吞吐量的原因是网络经常没有处于繁忙状态。
情况与使用装配流水线时不出一个完整产品就不准新的工作进入类似，流水线大部分时间是空闲的。
我们进一步对比，很明显，如果我们允许同一时间有多个工作单元进入流水，就可以做的更好。
对网络通信来说也是一样的---如果我们允许多个分组同时进入网络，就可以使它``更繁忙''，从而得到更高的吞吐量。

% 带来的问题:
% 1. 发送方: 维持ACK的计时器、未确认分组的副本
% 2. 接收方: 区分分组是否收到、维护混乱顺序的分组
% 3. 发送方、接收方、网络基础设施性能不均衡问题
很明显，允许多个分组同时进入网络使事情变得复杂。
现在发送方必须不仅要决定什么时间注入一个分组到网络中，还要注入多少个。
并且必须要指出在等待ACK时，怎样维持计时器，同时还必须要保存每个还没确认的分组的一个副本以防需要重传。
接收方需要有一个更复杂的ACK机制:可以区分哪些分组已经收到，哪些还没有。
接收方可能需要一个更复杂的缓存(分组保存)机制---允许维护``次序杂乱''的分组
(那些比预想要先到的分组更早到达的分组，因为丢包和次序重排的原因)，
除非简单地抛弃这些分组，而这样做是很没效率的。
还有其他一些没有这么明显的问题。
如果接收方的接收速率比发送方的发送速率要慢怎么办？
如果发送方简单地以很高的速率发送很多分组，接收方可能会因处理或内存的限制而丢掉这些分组。
中间的路由器也会有相同的问题。
如果网络基础设施处理不了发送方和接收方想要使用的数据发送率怎么办？


\subsection{分组窗口和滑动窗口}
为了解决所有这些问题，我们以假设每个分组有一个序列号开始，正如前面所描述的。
我们定义一个分组窗口(window)作为已被发送方注入但还未完成确认(如，发送方还从没收到它们的ACK)的分组(或者它们的序列号)的集合。
我们把这个窗口中的分组数量称为\emph{窗口大小}(window size)。
术语\emph{窗口}来自这样的想法:
如果你把在一个通信对话中发送的所有分组排成长长的一行，但只能通过一个小孔来观察它们，你就只能看到它们的一个子集---像通过一个窗口查看一样。
发送方的窗口(以及其他分组队列)可画图描述成图12-1那样。
\todo[inline]{图12-1 滑动窗口}

这个图显示了当前三个分组的窗口，整个窗口大小是3。
3号分组已经被发送和确认，所以由发送方保存的它的副本可以被释放。
分组7在发送方已经准备好，但还没被发送，因为它还没有``进入''窗口。
现在如果我们想象数据从发送方流到接收方，ACK开始以相反的方向流动，发送方可能下一步就接收到一个分组4的ACK。
当这发生时，窗口向右边``滑动''一个分组，意味着分组4的副本可以释放了，而分组7可以被发送了。
窗口的这种滑动给这种类型的协议增加了一个名字，\emph{滑动窗口}(sliding window)协议。

% 滑动窗口-发送方
% 结构: 1. 可被释放的分组 2. 等待ACK的分组 3. 未发送分组
% 滑动分组-接收方
% 结构: 1. 已被确认和接收的分组 2. 下一步期望的分组 3. 接收也因各种约束被丢弃的分组
这种滑动窗口方法可用于对付到目前为止描述过的许多问题。
一般来说，这个窗口结构在发送方和接收方都会有。
在发送方，它记录着哪些分组可被释放，哪些分组正在等待ACK，以及哪些分组还不能被发送。
在接收方，它记录着哪些分组已经被接收和确认，哪些分组是下一步期望的(和已经分配多少内存来保存它们)，以及哪些分组即使被接收也将会因内存限制而被丢弃。
尽管窗口结构便于记录在发送方和接收方之间流动的数据，但是关于窗口应多大，
    或者如果接收方或者网络处理不过来发送方的数据率时会发生什么，它都没有提供指导建议。现在我们应该看看这些怎样关联在一起。


\subsection{变量窗口: 流量控制和拥塞控制}
为了处理当接收方相对发送方太慢时产生的问题，我们介绍一种方法，在接收方跟不上时会强迫发送方慢下来。
这称为\emph{流量控制}(flow control)，该控制经常以下述两种方式之一来进行操作。
一种方式称\emph{基于速率}(rate-based)流量控制，它是给发送方指定某个速率，同时确保数据永远不能超过这个速率发送。
这种类型的流量控制最适合流应用程序，可被用于广播和组播发现(见第9章)。

另一种流量控制的主要形式叫\emph{基于窗口}(window-based)流量控制，是使用滑动窗口时最流行的方法。
在这种方法里，窗口大小不是固定的，而是允许随时间而变动的。
为了使用这种技术进行流量控制，必须有一种方法让接收方可以通知发送方使用多大的窗口。
这一般称为\emph{窗口通告}(window advertisement)，或简单地称为\emph{窗口更新}(window update)。
发送方(即窗口通告的接收者)使用该值调整其窗口大小。
逻辑上讲，一个窗口更新是与我们前面讨论过的ACK分离的，但是实际上窗口更新和ACK是由同一个分组携带的，
    意味着发送方往往会在它的窗口滑动到右边的同时调整它的大小。

如果我们考虑到在发送方修改窗口大小会带来的影响，就可以很明显地知道这是怎样达到流量控制的。
在没收到它们中任何一个的ACK之前，发送方允许注入$W$个分组到网络中。
如果发送方和接收方足够快，网络中没有丢失一个分组以及有无穷的空间的话，
    这意味着通信速度率正比于$(SW/R)$ b/s，这里$W$是窗口大小，$S$是分组大小(按比特算)，$R$是往返时间(RTT)。
当来自接收方的窗口通告夹带着发送方的值$W$时，那么发送方的全部速率就被限制而不能超越接收方。
这种方法可以很好地保护接收方，但是对于中间的网络呢？
在发送方和接收方之间可能会有有限内存的路由器，它们与低速网络链路抗争着。
当这种情况出现时，发送方的速率可能超过某个路由器的能力，从而导致丢包。
这由一种特殊的称为\emph{拥塞控制}(congestion control)的流量控制形式来处理。

拥塞控制设计发送方减低速度以至于压垮其与接收方之间的网络。
回想我们关于流量控制的讨论，我们使用一个窗口通告来告之发送方于接收方减慢速度。
这称为\emph{明确}(explicit)发信，因为有一个协议字段专用于通知发送方正在发生什么。
另一个选项可能被发送方用于\emph{猜测}(guess)它需要慢下来。
这种方法涉及\emph{隐性}(implicit)发信---涉及根据其他某些证据来决定减慢速度。

数据报类型的网络或更一般的与之关联的排队理论(queuing theory)中的拥塞控制问题仍然是这些年的一个主要研究课题，它甚至不太可能完全解决所有情况。
在这里讨论关于流量控制的所有选择和方法也不现实。
有兴趣的读者可参考\cite{Jain1990Congestion}、\cite{1997An}和\cite{Kleinrock1975Queueing}。
在第16章我们将更详细地探讨实际用于TCP中的拥塞控制技术，以及这些年来出现的许多变体。


\subsection{设置重传时间}
基于重传的可靠协议的设计者要面对一个最重要的性能问题是，要等待多久才能判定一个分组已丢失并将它重发。
用另一种方式说，重传超时应该是多大？
直观上看，发送方在重发一个分组之前应等待的时间量大概是下面时间的总和:
发送分组所用的时间、接收方处理它和发送一个ACK所用的时间、ACK返回到发送方所用的时间以及发送方处理ACK所用的时间。
不幸的是，实际上这些时间没有一个是可以确切知道的。
更糟的是，它们中的某些或全部会随着来自终端主机或路由器的额外负载的增加或减少而随时改变。

让用户去告诉协议实现在所有情况下的每个时刻应取什么超时时间(或使它们保持最新)，这是不现实的，一个更好的策略是让协议实现尝试去估计它们。
这称为\emph{往返时间估计}(round-trip-time estimation)，这是一个统计过程。
总的来说，选择一组RTT样本的样本均值作为真实的RTT是最有可能的。
注意到这个平均值很自然地会随着时间而改变(它不是静态的)，因为通信穿过网络的路径可能会改变。

作出对RTT的一些估计之后，关于设置实际的用于触发重传的超时取值问题依然存在。
如果我们回想一下均值的定义，会知道它绝不可能是一组样本的均值(除非它们全部一样)。
所以，把重传计时器的值设置成正好等于平均估计量是不合理的，因为很有可能许多实际的RTT将会比较大，从而会导致不必要的重传。
很明显，超时应该设置成比均值要大的某个值，但是这个值与均值的确切关系是什么(或者甚至直接就使用均值)还不清楚。
超时设置得太大也是不可取的，因为这反过来会导致网络变得空闲，从而降低吞吐量。
对于这个话题的进一步探究留到第14章，我们在那里会探讨TCP是怎样实际地处理这个问题的。


\section{TCP的引入}
我们现在对影响可靠传输的问题有了大体的了解，下面看一下它们是怎样在TCP中体现的，以及TCP会给互联网应用程序提供什么类型的服务。
我们还要查看TCP头部中的字段，了解有多少个到目前为止我们已经见过的概念(如ACK、窗口通告)可在头部描述中捕捉到。
在随后的章节，我们会更详细地检查所有这些头部字段。

我们对TCP的描述从这一章开始，并在接下来的五章中继续讨论。
第13章描述一个TCP连接是怎样建立和结束的。
第14章详细说明TCP是怎样估计每个链接的RTT和怎样基于这个估计设置重传超时的。
第15章考察正常的数据传输，以``交互式''应用程序开始(例如聊天程序)，然后是窗口管理和流量控制，
    这被应用于交互式和``大块''数据流(比如文件传输)两种应用程序以及TCP的\emph{紧急机制}(urgent machanism)---
    它允许发送方指定数据流中的某些数据作为特殊数据。
第16章考察了TCP里的拥塞控制算法，这些算法在网络很繁忙中的时候帮助降低丢包率。
这一章还讨论了一些改动，这些改动被提出来以增加快速网络的吞吐量和改进易损耗(如无线)网络的弹性。
最后，第17章显示TCP如何在没有数据流动时保持连接的活动性。
\todo[inline]{相关参考}


\subsection{TCP服务模型}
虽然TCP和UDP使用相同的网络层(IPv4或IPv6)，但是TCP给应用程序提供了一种与UDP完全不同的服务。
TCP提供了一种\emph{面向连接的}(connection-oriented)、可靠的字节流服务。
术语``面向连接的''是指使用TCP的两个应用程序必须在它们交换数据之前，通过相互联系来建立一个TCP连接。
最典型的比喻就是拨打一个电话号吗，等待另一方接听电话并说``喂''，然后再说``找谁？''。
这正是一个TCP连接的两个端点在互相通信。像广播和组播(见第9章)这些概念在TCP中都不存在。

TCP提供一种字节流抽象概念给应用程序使用。
这种设计方案的结果是，没有由TCP自动插入的记录标志和消息边界(见第1章)。
一个记录标志对应着一个应用程序的写范围指示。
如果应用程序在一端写入10字节，随后写入20字节，再随后写入50字节，那么在连接的另一端的应用程序是不知道每次写入的字节是多少的。
例如，另一端可能会以每次20字节分四次读入这80字节或以其他一些方式读入。
一端给TCP输入字节流，同样的字节流会出现在另一端。
每个端点独立选择自己的读和写大小。

TCP根本不会解读字节流里的字节内容。
它不知道正在交换的数据字节是不是二进制数据、ASCII字符、EBCDIC字符或其他东西。
对这个字节流的解读取决于连接中的每个端点的应用程序。
尽管不再推荐使用，可TCP确实是支持以前提到过的紧急机制。


\subsection{TCP中的可靠性}
通过使用刚才描述的那些技术的特定变种，TCP提供了可靠性。
因为它提供了一个字节流接口，TCP必须把一个发送应用程序的字节流转换成一组IP可以携带的分组。
这被称为\emph{组包}(packetization)。
这些分组包含序列号，
    该序列号在TCP中实际代表了每个分组的第一个字节在整个数据流中的字节偏移，而不是分组号。
这允许分组在传送中是可变大小的，并允许它们组合，称为\emph{重新组包}(repacketization).
应用程序数据被打散成TCP认为的最佳大小的块来发送，
    一般使得每个报文段按照不会被分片的单个IP层数据包的大小来划分。
这与UDP不同，应用程序每次写入通常就产生一个UDP数据，其大小就是写入的那么大(加上头部)。
由TCP传给IP的块称为\emph{报文段}(segment, 见图12-2)。
在第15章我们会看到TCP如何判定一个报文段的大小。

TCP维持了一个强制的校验和，该校验和涉及它的头部、任何相关应用程序数据和IP头部的所有字段。
这是一个端到端的伪头部，它用于检测传送中引入的比特差错。
如果一个带无效校验和的报文段到达，那么TCP会丢弃它，不为被丢弃的分组发送任何确认。
然而，TCP接收端可能会对一个以前的(已经确认的)报文段进行确认，以帮助发送方计算它的拥塞控制(第16章)。
TCP校验和使用的数学函数与其他互联网协议(UDP、ICMP等)一样。
对于大数据的传送，对这个校验和是否不够强壮的担心是存在的，
    所以仔细的应用程序应该应用自己的差错保护方法(如，更强的校验和或CRC)，
    或者使用一种中间层来达到同样的效果。

当TCP发送一组报文段时，它通常设置一个重传计时器，等待对方的确认接收。
TCP不会为每个报文段设置一个不同的重传计时器。
相反，发送一个窗口的数据，它只设置一个计时器，当ACK到达时再更新超时。
如果有一个确认没有及时接收到，这个报文段就会被重传。
在第14章我们将更详细地查看TCP的自适应超时和重传策略。

当TCP接收到连接的另一端的数据时，它会发送一个确认。
这个确认可能不会立即发送，而一般会延迟片刻。
TCP使用的ACK是\emph{累积}的，从某种意义上来讲，
    一个指示字节号$N$的ACK暗示着所有直到$N$的字节(但不包括$N$)已经成功被接收了。
这对于ACK丢失来说带来了一定的鲁棒性---如果一个ACK丢失，很有可能后续的ACK就足以确认前面的报文段了。

TCP给应用程序提供一种\emph{双工}服务。
这就是说数据可向两个方向流动，两个方向互相独立。
因此，连接的每个端点必须对每个方向维护数据流的一个序列号。
一旦建立了一个连接，这个连接的一个方向上的包含数据流的每个TCP报文段也包含了相反方向上的报文段的一个ACK。
每个报文段也包含了一个窗口通告以实现相反方向上的流量控制。
为此，在一个连接中，当一个TCP报文段到达时，窗口可能向前滑动，窗口大小可能改变，同时新数据可能已到达。
正如我们将在第13章所见，一个完整的TCP连接是双向和对称的，数据可以在两个方向上平等地流动。

使用序列号，一个TCP接收端可丢弃重复的报文段和记录以杂乱次序到达的报文段。
回想一下，任何反常情况都会发生，因为TCP使用IP来传递它的报文段，IP不提供重复消除或保证次序正确的功能。
然而，因为TCP是一个字节流协议，TCP绝不会以杂乱的次序接收\emph{应用程序}发送数据。
因此，TCP接收端可能会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段(一个``洞'')被填满。

我们现在开始观察TCP的一些细节。
这一章只介绍TCP的封装和头部结构，其他细节出现在后面的五章中。
TCP可以与IPv4或IPv6使用，同时它使用的伪头部(与UDP的类似)在IPv4中和IPv6中都是强制使用的。


\section{TCP头部和封装}
图12-2显示了TCP在IP数据报中的封装。
\todo[inline]{图12-2 TCP在IP数据报中的封装}

头部本身明显要比在第10章我们见过的UDP的头部更复杂。
这并不很令人惊讶，因为TCP是一个明显更复杂的协议，它必须保持连接的每一端知道(同步)最新状态。
如图12-3所示。
\todo[inline]{图12-3 TCP头}

每一个TCP头部包含了源和目的端口号，这两个值与IP头部中的源和目的IP地址一起，唯一地标识了每个连接。
在TCP术语中，一个IP地址和一个端口的组合有时候被称为一个\emph{端点(endpoint)}或\emph{套接字(socket)}。
后者出现在\cite{1981Transmission}中，最终被Berkeley系列的网络通信编程接口所采用(现在经常被称为``Berkeley套接字'')。
每个TCP连接由一对套接字或端点(四元组，由客户机IP地址、客户机端口号、服务器IP地址以及服务器端口号组成)唯一地标识。
这个事实在我们观察一个TCP服务器是如何做到与多个客户机通信的时候将会变得非常重要(见第13章)。

\emph{序列号(Sequence Number)}字段标识了TCP发送端到TCP接收端的数据流的一个字节，
    该字节代表着包含该序列号的报文段的数据中的第一个字节。
如果我们考虑在两个应用程序之间的一个方向上流动的数据流，TCP给每个字节赋予一个序列号
这个序列号是一个32位的无符号数，到达$2^{32}-1$后再循环回到0。
因为每个被交换的字节都已被编号，\emph{确认号}字段(也简称ACK号或ACK字段)包含的值是该确认号的发送方期待接收的下一个序列号。
即最后被成功接收的数据字节的序列号加1。
这个字段只有在ACK位字段被启用的情况下才有效，这个ACK位字段通常用于除了初始和末尾报文段之外的所有报文段。
发送一个ACK和发送任何一个TCP报文段的开销是一样的，因为那个32位的ACK号字段一直都是头部的一部分，ACK位字段也一样。

当建立一个新连接时，从客户机器发送至服务器的第一个报文段的SYN位字段被启用。
这样的报文段被称为\emph{SYN报文段}，或简单地称为SYN。
然后\emph{序列号}字段包含了在本次连接的这个方向上要使用的第一个序列号，后续序列号和返回的ACK号也在这个方向上(回想一下，连接是双向的)。
注意这个数字\emph{不是0和1}，而是另外一个数字，经常是随机选择的，称为\emph{初始序列号(Initial Sequence Number, ISN)}。
ISN不是0和1，是因为这是一种安全措施，将会在第13章讨论。
发送在本次连接的这个方向上的数据的第一个字节的序列号是ISN加1，因为SYN位字段会\emph{消耗}一个序列号。
正如我们稍后将见到的，消耗一个序列号也意味着使用重传进行可靠传输。
因此，SYN和应用程序字节(还有FIN，稍后我们将见到)是被可靠传输的。
不消耗序列号的ACK则不是。

TCP可以被描述为``一种带累积正向确认的滑动窗口协议''。
\emph{ACK号}字段被构建用于指明在接收方已经顺序收到的最大字节(加1)。
例如，如果字节1~1024已经接收成功，而下一个报文段包含字节2049~3072，
    那么接收方不能使用规则的ACK号字段去发信告诉发送方它接收到了这个新报文段。
然而，现代TCP有一个\emph{选择确认(Selective ACKnowledgment, SACK)}选项，可以允许接收方告诉发送方它正确地接收到了次序杂乱的数据。
当于一个具有\emph{选择重发(selective repeat)}能力的TCP发送方搭配时，就可以实现性能的显著改善。
在第14章我们将会看到TCP是如何使用\emph{重复确认(duplicate acknowledgments)}以帮助它的拥塞控制和差错控制过程的。

\emph{头部长度}字段给出了头部的长度，以32位字为单位。
它是必须的，因为\emph{选项}字段的长度是可变的。
作为一个4位的字段，TCP被限制为只能带60字节的头部。
而不带选项，大小是20字节。

当前，为TCP头部定义了8位的字段可，尽管一些老的实现只理解它们中的最后6位。
它们中的一个或多个可被同时启用。
我们在这里大致提一下它们的用法，在后面几章里再对每个进行详细的讨论。
\begin{enumerate}
    \item CWR --- 拥塞窗口减(发送方降低它的发送速率)；见第16章。
    \item ECE --- ECN回显(发送方接收到了一个更早的拥塞通告)；见第16章。
    \item URG --- 紧急(紧急指针字段有效---很少被使用)；见第15章。
    \item ACK --- 确认(确认号字段有效---连接建立以后一般都是启用状态)；见第13章和第15章。
    \item PSH --- 推送(接收方应尽快给应用程序传送这个数据---没被可靠地实现或用到)；见第15章。
    \item RST --- 重置连接(连接取消，经常是因为错误)；见第13章。
    \item SYN --- 用于初始化一个连接的同步序列号；见第13章。
    \item FIN --- 该报文段的发送方已经结束向对方发送数据；见第13章。
\end{enumerate}

TCP的流量控制由每个端点使用\emph{窗口大小}字段通告一个窗口大小来完成。
这个窗口大小是字节数，从ACK号指定的，也是接收方想要接收的那个字节开始。
这是一个16位的字段，限制了窗口大小到65535字节，从而限制了TCP的吞吐量性能。
在第15章我们将看到窗口缩放(Window Scale)选项可允许对这个值进行缩放，给高速和大延迟网络提供了更大的窗口和改进性能。

TCP\emph{校验和}字段覆盖了TCP的头部和数据以及头部中的一些字段，
    使用一个与我们在第8章和第10章讨论的ICMPv6与UDP使用的相类似伪头部进行计算。
这个字段是强制的，由发送方进行计算和保存，然后由接收方验证。
TCP校验和的计算算法与IP、ICMP和UDP(``互联网'')校验和一样。

\emph{紧急指针(Urgent Pointer)}字段只有在URG位字段被设置时才有用。
这个``指针''是一个必须要加到报文段的\emph{序列号}字段上的正偏移，以产生紧急数据的\emph{最后}一个字节的序列号。
TCP的紧急机制是一种让发送方给另一端提供特殊标志数据的方法。

最常见的\emph{选项}字段就是``最大段大小''选项，称为MSS。
连接的每个端点一般在它发送的第一个报文段(为了建立该连接，SYN位字段被设置的那个报文段)上指定这个选项。
MSS指定该选项的发送着在相反方向上希望接收到的最大报文段的最大值。
在第13章我们将更详细地描述MSS选项，并在第14章和第15章描述其他一些TCP选项。
我们考察的其他普通选项还包括SACK、时间戳和窗口缩放。

在图12-2中我们主要到TCP报文段的数据部分是可选的。
在第13章我们将看到的一个连接被建立和终止时，交换的报文段只包含了TCP头部(带或不带选项)而没有数据。
如果这个方向上没有数据被传输，那么一个不带任何数据的头部也会被用于确认接收到的数据(称为一个\emph{纯(pure)}ACK),
    同时通知通信方改变窗口大小(称为一个\emph{窗口更新(window update)})。
当一个报文段可不带数据发送时，超时操作会因此而产生一些新情况。


\section{总结}
在有损通信信道上提供可靠通信的问题已经被研究了许多年。
处理差错的两种主要方法是差错矫正码和数据重传。
使用重传的协议必须也要处理数据丢失，经常通过设置一个计时器来进行，同时还必须要给接收方安排一些方法来告知发送方它已接收了什么。
判定等待一个ACK要多长时间是比较棘手的，因为合适的时间会随着网络路由或端点上负载的变动而改变。
现代协议用基于这些测量值的一些函数来估计往返时间以及设置重传计时器。

不考虑设置重传计时器的话，当同一时间只有一个分组在网络中时，重传协议时很简单的，
    但对于延迟很高的网络，它们的性能很差。
为了更有效率，在一个ACK被接收到之前，多个分组必须被注入网络中。
这种方法更有效率，但也更复杂。
一种管理这些复杂性的典型方法时使用滑动窗口，其中分组用序列号标志，窗口大小限制分组数量。
当窗口大小基于来自接收方或其他信号(比如被丢弃的分组)的回馈而改变时，流量控制和拥塞控制两者就都被实现了。

TCP提供一种可靠，面向连接、字节流、传输层的服务(通过使用许多这些技术而构建)。
我们简单地看了TCP头部里的所有字段，了解到它们中的大多数都与这些可靠传递的抽象概念有着直接关系。
我们将在接下来的章节里详细考察它们。
TCP把应用程序数据组包成报文段，发送数据时设置超时，确认被其他端点接收到的数据，给次序杂乱的数据进行重新排序，
    丢弃重复的数据，提供端到端的校验和。
TCP在互联网中被广泛应用，不仅许多流行的应用程序使用它，
    例如HTTP、SSH/TLS、NetBIOS(NBT---NetBIOS over TCP)、Telnet、FTP以及电子邮件(SMTP)，
    许多分布式文件共享程序(如，BitTorrent，Shareaza)也使用它。

% \begin{compactenum}[1.]
%     \item 接收方是否已收到分组；
%     \item 接收方接收到的分组是否与之前发送方发送的一样。
% \end{compactenum}

\end{document}